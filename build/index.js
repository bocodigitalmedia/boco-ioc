// Generated by CoffeeScript 1.10.0
var configure,
  slice = [].slice,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

configure = function(arg) {
  var Async, Component, ComponentAlreadyDefined, ComponentDependenciesNotDefined, ComponentFactory, ComponentLoader, ComponentNotAcyclic, ComponentNotDefined, ComponentTimedOut, ComponentWithDependenciesArray, ComponentWithDependenciesObject, ComponentWithoutDependencies, Container, EventEmitter, Exception, Glob, IOC, NotImplemented, Path, Promise, promiseCallback, ref;
  ref = arg != null ? arg : {}, Async = ref.Async, Promise = ref.Promise, Glob = ref.Glob, Path = ref.Path, EventEmitter = ref.EventEmitter, promiseCallback = ref.promiseCallback;
  if (typeof require === 'function') {
    if (Async == null) {
      Async = require('async');
    }
    if (Promise == null) {
      Promise = require('bluebird');
    }
    if (Glob == null) {
      Glob = require('glob');
    }
    if (Path == null) {
      Path = require('path');
    }
    if (EventEmitter == null) {
      EventEmitter = require('events').EventEmitter;
    }
  }
  if (promiseCallback == null) {
    promiseCallback = function(promise, done) {
      var fn, reject, resolve;
      fn = typeof promise.done === 'function' ? 'done' : 'then';
      resolve = function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return done.apply(null, [null].concat(slice.call(args)));
      };
      reject = function(error) {
        return done(error);
      };
      return promise[fn](resolve, reject);
    };
  }
  Exception = (function(superClass) {
    extend(Exception, superClass);

    Exception.prototype.name = null;

    Exception.prototype.payload = null;

    function Exception(payload) {
      if (!(this instanceof Exception)) {
        return new Exception(payload);
      }
      this.payload = payload;
      this.name = this.constructor.name;
      Error.captureStackTrace(this, this.constructor);
    }

    return Exception;

  })(Error);
  ComponentTimedOut = (function(superClass) {
    extend(ComponentTimedOut, superClass);

    function ComponentTimedOut(payload) {
      if (!(this instanceof ComponentTimedOut)) {
        return new ComponentTimedOut(payload);
      }
      ComponentTimedOut.__super__.constructor.call(this, payload);
      this.message = "Component '" + this.payload.key + "' timed out.";
    }

    return ComponentTimedOut;

  })(Exception);
  NotImplemented = (function(superClass) {
    extend(NotImplemented, superClass);

    function NotImplemented(payload) {
      if (!(this instanceof NotImplemented)) {
        return new NotImplemented(payload);
      }
      NotImplemented.__super__.constructor.call(this, payload);
      this.message = "Not implemented.";
    }

    return NotImplemented;

  })(Exception);
  ComponentAlreadyDefined = (function(superClass) {
    extend(ComponentAlreadyDefined, superClass);

    function ComponentAlreadyDefined(payload) {
      if (!(this instanceof ComponentAlreadyDefined)) {
        return new ComponentAlreadyDefined(payload);
      }
      ComponentAlreadyDefined.__super__.constructor.call(this, payload);
      this.message = "Component already defined: '" + this.payload.key + "'.";
    }

    return ComponentAlreadyDefined;

  })(Exception);
  ComponentNotDefined = (function(superClass) {
    extend(ComponentNotDefined, superClass);

    function ComponentNotDefined(payload) {
      if (!(this instanceof ComponentNotDefined)) {
        return new ComponentNotDefined(payload);
      }
      ComponentNotDefined.__super__.constructor.call(this, payload);
      this.message = "Component not defined: '" + this.payload.key + "'.";
    }

    return ComponentNotDefined;

  })(Exception);
  ComponentDependenciesNotDefined = (function(superClass) {
    extend(ComponentDependenciesNotDefined, superClass);

    function ComponentDependenciesNotDefined(payload) {
      if (!(this instanceof ComponentDependenciesNotDefined)) {
        return new ComponentDependenciesNotDefined(payload);
      }
      ComponentDependenciesNotDefined.__super__.constructor.call(this, payload);
      this.message = "Component '" + this.payload.key + "' has undefined dependencies: " + (this.payload.dependencies.join(',')) + ".";
    }

    return ComponentDependenciesNotDefined;

  })(Exception);
  ComponentNotAcyclic = (function(superClass) {
    extend(ComponentNotAcyclic, superClass);

    function ComponentNotAcyclic(payload) {
      var count, cycles;
      if (!(this instanceof ComponentNotAcyclic)) {
        return new ComponentNotAcyclic(payload);
      }
      ComponentNotAcyclic.__super__.constructor.call(this, payload);
      count = this.payload.cycles.length;
      cycles = this.payload.cycles.map(function(cycle, index) {
        return "\t" + index + ": " + (cycle.join('/'));
      }).join("\n");
      this.message = "Component '" + this.payload.key + "' has " + count + " dependency cycle(s):\n" + cycles;
    }

    return ComponentNotAcyclic;

  })(Exception);
  Component = (function() {
    Component.prototype.key = null;

    Component.prototype.dependencies = null;

    Component.prototype.factory = null;

    Component.prototype.factoryType = null;

    function Component(props) {
      var ref1, ref2, ref3;
      if (props == null) {
        props = {};
      }
      this.key = props.key;
      this.factoryType = (ref1 = props.factoryType) != null ? ref1 : null;
      this.dependencies = (ref2 = props.dependencies) != null ? ref2 : null;
      this.factory = (ref3 = props.factory) != null ? ref3 : function() {
        var done, i, injections;
        injections = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), done = arguments[i++];
        if (typeof done === 'function') {
          return done(NotImplemented());
        }
        throw NotImplemented();
      };
    }

    Component.prototype.getDependencyKeys = function() {
      throw NotImplemented();
    };

    Component.prototype.guessFactoryType = function() {
      return 'async';
    };

    Component.prototype.getFactoryType = function() {
      var ref1;
      return (ref1 = this.factoryType) != null ? ref1 : this.guessFactoryType();
    };

    Component.prototype.injectPromiseFactory = function(injections, done) {
      return this.injectSyncFactory(injections, function(error, promise) {
        if (error != null) {
          return done(error);
        }
        return promiseCallback(promise, done);
      });
    };

    Component.prototype.injectAsyncFactory = function(injections, done) {
      if (typeof done === 'function') {
        return done(NotImplemented());
      }
      throw NotImplemented();
    };

    Component.prototype.injectSyncFactory = function(injections, done) {
      if (typeof done === 'function') {
        return done(NotImplemented());
      }
      throw NotImplemented();
    };

    Component.prototype.inject = function(injections, done) {
      switch (this.getFactoryType()) {
        case 'promise':
          return this.injectPromiseFactory(injections, done);
        case 'async':
          return this.injectAsyncFactory(injections, done);
        case 'sync':
          return this.injectSyncFactory(injections, done);
        default:
          throw Error("Cannot inject component, unknown factoryType: '" + this.factoryType + "'");
      }
    };

    return Component;

  })();
  ComponentWithDependenciesArray = (function(superClass) {
    extend(ComponentWithDependenciesArray, superClass);

    function ComponentWithDependenciesArray() {
      return ComponentWithDependenciesArray.__super__.constructor.apply(this, arguments);
    }

    ComponentWithDependenciesArray.prototype.getDependencyKeys = function() {
      var ref1;
      return (ref1 = this.dependencies) != null ? ref1 : [];
    };

    ComponentWithDependenciesArray.prototype.guessFactoryType = function() {
      if (this.factory.length === this.dependencies.length) {
        return 'sync';
      }
      return 'async';
    };

    ComponentWithDependenciesArray.prototype.injectAsyncFactory = function(injections, done) {
      var error, error1;
      try {
        return this.factory.apply(this, slice.call(injections).concat([done]));
      } catch (error1) {
        error = error1;
        return done(error);
      }
    };

    ComponentWithDependenciesArray.prototype.injectSyncFactory = function(injections, done) {
      var error, error1;
      try {
        return done(null, this.factory.apply(this, injections));
      } catch (error1) {
        error = error1;
        return done(error);
      }
    };

    return ComponentWithDependenciesArray;

  })(Component);
  ComponentWithDependenciesObject = (function(superClass) {
    extend(ComponentWithDependenciesObject, superClass);

    function ComponentWithDependenciesObject() {
      return ComponentWithDependenciesObject.__super__.constructor.apply(this, arguments);
    }

    ComponentWithDependenciesObject.prototype.getDependencyKeys = function() {
      var key, val;
      return ((function() {
        var ref1, results;
        ref1 = this.dependencies;
        results = [];
        for (key in ref1) {
          if (!hasProp.call(ref1, key)) continue;
          val = ref1[key];
          results.push({
            key: key,
            val: val
          });
        }
        return results;
      }).call(this)).map(function(arg1) {
        var key, val;
        key = arg1.key, val = arg1.val;
        if (typeof val === 'string') {
          return val;
        } else {
          return key;
        }
      });
    };

    ComponentWithDependenciesObject.prototype.guessFactoryType = function() {
      if (this.dependencies.length === 0 && this.factory.length === 0) {
        return 'sync';
      }
      if (this.factory.length === 1) {
        return 'sync';
      }
      return 'async';
    };

    ComponentWithDependenciesObject.prototype.createInjectionObject = function(injections) {
      var collectInjections, injectionKeys, injectionObject, key;
      collectInjections = function(memo, key, index) {
        memo[key] = injections[index];
        return memo;
      };
      injectionKeys = (function() {
        var ref1, results;
        ref1 = this.dependencies;
        results = [];
        for (key in ref1) {
          if (!hasProp.call(ref1, key)) continue;
          results.push(key);
        }
        return results;
      }).call(this);
      injectionObject = injectionKeys.reduce(collectInjections, {});
      return injectionObject;
    };

    ComponentWithDependenciesObject.prototype.injectSyncFactory = function(injections, done) {
      var error, error1, injectionObject;
      injectionObject = this.createInjectionObject(injections);
      try {
        return done(null, this.factory(injectionObject));
      } catch (error1) {
        error = error1;
        return done(error);
      }
    };

    ComponentWithDependenciesObject.prototype.injectAsyncFactory = function(injections, done) {
      var error, error1, injectionObject;
      injectionObject = this.createInjectionObject(injections);
      try {
        return this.factory(injectionObject, done);
      } catch (error1) {
        error = error1;
        return done(error);
      }
    };

    return ComponentWithDependenciesObject;

  })(Component);
  ComponentWithoutDependencies = (function(superClass) {
    extend(ComponentWithoutDependencies, superClass);

    function ComponentWithoutDependencies() {
      return ComponentWithoutDependencies.__super__.constructor.apply(this, arguments);
    }

    ComponentWithoutDependencies.prototype.getDependencyKeys = function() {
      return [];
    };

    ComponentWithoutDependencies.prototype.guessFactoryType = function() {
      if (this.factory.length === 1) {
        return 'async';
      }
      return 'sync';
    };

    ComponentWithoutDependencies.prototype.injectAsyncFactory = function(injections, done) {
      var error, error1;
      try {
        return this.factory(done);
      } catch (error1) {
        error = error1;
        return done(error);
      }
    };

    ComponentWithoutDependencies.prototype.injectSyncFactory = function(injections, done) {
      var error, error1;
      try {
        return done(null, this.factory());
      } catch (error1) {
        error = error1;
        return done(error);
      }
    };

    return ComponentWithoutDependencies;

  })(Component);
  Container = (function() {
    Container.prototype.components = null;

    Container.prototype.promises = null;

    Container.prototype.componentFactory = null;

    Container.prototype.componentTimeout = null;

    function Container(props) {
      var ref1, ref2, ref3, ref4, ref5;
      if (props == null) {
        props = {};
      }
      this.components = (ref1 = props.components) != null ? ref1 : Object.create(null);
      this.promises = (ref2 = props.promises) != null ? ref2 : Object.create(null);
      this.componentFactory = (ref3 = props.componentFactory) != null ? ref3 : new ComponentFactory;
      this.componentTimeout = (ref4 = props.componentTimeout) != null ? ref4 : 30000;
      this.emitter = (ref5 = props.emitter) != null ? ref5 : new EventEmitter;
    }

    Container.prototype.on = function() {
      var args, ref1;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref1 = this.emitter).on.apply(ref1, args);
    };

    Container.prototype.once = function() {
      var args, ref1;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref1 = this.emitter).once.apply(ref1, args);
    };

    Container.prototype.removeListener = function() {
      var args, ref1;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref1 = this.emitter).removeListener.apply(ref1, args);
    };

    Container.prototype.removeAllListeners = function() {
      var args, ref1;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref1 = this.emitter).removeAllListeners.apply(ref1, args);
    };

    Container.prototype.defineComponent = function() {
      var args, key, ref1;
      key = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (this.components[key] != null) {
        throw ComponentAlreadyDefined({
          key: key
        });
      }
      this.components[key] = (ref1 = this.componentFactory).construct.apply(ref1, args);
      delete this.promises[key];
      return this.emitter.emit("component.defined", {
        key: key,
        container: this
      });
    };

    Container.prototype.createComponentPromise = function(key) {
      this.emitter.emit("component.resolving", {
        key: key,
        container: this
      });
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var component, dependencyKeys, done, timeoutId;
          done = function(error, result) {
            if (typeof timeoutId !== "undefined" && timeoutId !== null) {
              clearTimeout(timeoutId);
            }
            if (error != null) {
              reject(error);
              return _this.emitter.emit('component.error', {
                key: key,
                container: _this,
                error: error
              });
            } else {
              resolve(result);
              return _this.emitter.emit('component.resolved', {
                key: key,
                container: _this,
                result: result
              });
            }
          };
          timeoutId = setTimeout(done.bind(null, ComponentTimedOut({
            key: key
          })), _this.componentTimeout);
          component = _this.components[key];
          dependencyKeys = component.getDependencyKeys();
          return Async.map(dependencyKeys, _this.resolveComponent.bind(_this), function(error, injections) {
            if (error != null) {
              return done(error);
            }
            return component.inject(injections, done);
          });
        };
      })(this));
    };

    Container.prototype.isComponentDefined = function(key) {
      return this.components[key] != null;
    };

    Container.prototype.assertComponentDefined = function(key) {
      if (!this.isComponentDefined(key)) {
        throw ComponentNotDefined({
          key: key
        });
      }
    };

    Container.prototype.assertComponentDependenciesDefined = function(key) {
      var component, dependencies;
      component = this.components[key];
      dependencies = component.getDependencyKeys().filter((function(_this) {
        return function(key) {
          return !_this.isComponentDefined(key);
        };
      })(this));
      if (dependencies.length) {
        throw ComponentDependenciesNotDefined({
          key: key,
          dependencies: dependencies
        });
      }
    };

    Container.prototype.getComponentCycles = function(key, stack) {
      var component, dependencyKeys, reduceDependencyCycles;
      if (stack == null) {
        stack = [];
      }
      if (indexOf.call(stack, key) >= 0) {
        return [stack.concat(key)];
      }
      component = this.components[key];
      if (component == null) {
        return [];
      }
      stack = stack.concat(key);
      reduceDependencyCycles = (function(_this) {
        return function(memo, key) {
          return memo.concat(_this.getComponentCycles(key, stack));
        };
      })(this);
      dependencyKeys = component.getDependencyKeys();
      return dependencyKeys.reduce(reduceDependencyCycles, []);
    };

    Container.prototype.assertComponentAcyclic = function(key) {
      var cycles;
      cycles = this.getComponentCycles(key);
      if (cycles.length) {
        throw ComponentNotAcyclic({
          key: key,
          cycles: cycles
        });
      }
    };

    Container.prototype.validateComponent = function(key) {
      this.assertComponentDefined(key);
      this.assertComponentDependenciesDefined(key);
      return this.assertComponentAcyclic(key);
    };

    Container.prototype.validateComponents = function() {
      var key, ref1, results;
      ref1 = this.components;
      results = [];
      for (key in ref1) {
        if (!hasProp.call(ref1, key)) continue;
        results.push(this.validateComponent(key));
      }
      return results;
    };

    Container.prototype.resolveComponent = function(key, done) {
      var error, error1;
      if (!this.promises[key]) {
        try {
          this.validateComponent(key);
        } catch (error1) {
          error = error1;
          return done(error);
        }
        this.promises[key] = this.createComponentPromise(key);
      }
      return promiseCallback(this.promises[key], done);
    };

    return Container;

  })();
  ComponentFactory = (function() {
    function ComponentFactory() {}

    ComponentFactory.prototype.construct = function(arg1) {
      var dependencies, depends, factory, factoryType, key;
      key = arg1.key, dependencies = arg1.dependencies, depends = arg1.depends, factory = arg1.factory, factoryType = arg1.factoryType;
      if (dependencies == null) {
        dependencies = depends;
      }
      if (dependencies == null) {
        return new ComponentWithoutDependencies({
          key: key,
          factory: factory,
          factoryType: factoryType
        });
      }
      if (Array.isArray(dependencies)) {
        return new ComponentWithDependenciesArray({
          key: key,
          dependencies: dependencies,
          factory: factory,
          factoryType: factoryType
        });
      }
      if (typeof dependencies === 'object') {
        return new ComponentWithDependenciesObject({
          key: key,
          dependencies: dependencies,
          factory: factory,
          factoryType: factoryType
        });
      }
      throw Error("Cannot construct component, invalid dependencies.");
    };

    return ComponentFactory;

  })();
  ComponentLoader = (function() {
    function ComponentLoader() {}

    ComponentLoader.prototype.load = function(arg1) {
      var componentsDir, container, pattern;
      container = arg1.container, componentsDir = arg1.componentsDir, pattern = arg1.pattern;
      if (componentsDir == null) {
        componentsDir = Path.resolve(__dirname, "components");
      }
      if (pattern == null) {
        pattern = "**/*(*.coffee|*.js)";
      }
      return Glob.sync(pattern, {
        cwd: componentsDir
      }).forEach(function(componentPath) {
        var definition, dirname, extname, filename, key, modname;
        dirname = Path.dirname(componentPath);
        filename = Path.basename(componentPath);
        extname = Path.extname(componentPath);
        modname = (function() {
          return filename.slice(0, filename.length - extname.length);
        })();
        key = dirname === '.' ? modname : Path.join(dirname, modname);
        definition = require(Path.resolve(componentsDir, dirname, filename));
        return container.defineComponent(key, definition);
      });
    };

    return ComponentLoader;

  })();
  return IOC = {
    configure: configure,
    Container: Container,
    ComponentFactory: ComponentFactory,
    Component: Component,
    ComponentWithoutDependencies: ComponentWithoutDependencies,
    ComponentWithDependenciesObject: ComponentWithDependenciesObject,
    ComponentWithDependenciesArray: ComponentWithDependenciesArray,
    Exception: Exception,
    NotImplemented: NotImplemented,
    ComponentNotDefined: ComponentNotDefined,
    ComponentDependenciesNotDefined: ComponentDependenciesNotDefined,
    ComponentNotAcyclic: ComponentNotAcyclic,
    ComponentAlreadyDefined: ComponentAlreadyDefined,
    ComponentLoader: ComponentLoader
  };
};

module.exports = configure();

//# sourceMappingURL=index.js.map
